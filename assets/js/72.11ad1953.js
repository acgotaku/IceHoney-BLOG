(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{415:function(e,a,t){"use strict";t.r(a);var r=t(10),n=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("最近的工作是做嵌入在 iOS 程序内部的页面，其中有一个需求就是需要满足在离线的情况下显示页面。当然，现在主流的离线方式是使用 Service Worker 来完成离线需求。\n但是 iOS 内置的 WKWebView 并不支持最新的 Service Worker（取决于 iOS 版本）最新版本已经支持，所以不得不想办法来解决。")]),e._v(" "),t("h2",{attrs:{id:"application-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#application-cache"}},[e._v("#")]),e._v(" Application Cache")]),e._v(" "),t("p",[e._v("AppCache 是一个过时的技术，但是在 iOS 下勉强还能用。不过 Chrome 对这种过时的技术支持不是很好，单个缓存文件最大只支持 5MB。而且还有请求的 BUG:"),t("a",{attrs:{href:"https://bugs.chromium.org/p/chromium/issues/detail?id=140445",target:"_blank",rel:"noopener noreferrer"}},[e._v("Accept header on GET request for appcache manifest"),t("OutboundLink")],1),e._v("。触发 AppCache 是在 html 标签中添加 manifest 属性。")]),e._v(" "),t("div",{staticClass:"language-html line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("html")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("manifest")]),t("span",{pre:!0,attrs:{class:"token attr-value"}},[t("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[e._v("=")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')]),e._v("manifest.appcache"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')])]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n  ...\n"),t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token tag"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("html")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("p",[e._v("通过"),t("code",[e._v("manifest.appcache")]),e._v("文件来定义需要缓存的文件，不过载入"),t("code",[e._v("manifest.appcache")]),e._v("的页面会被作为"),t("code",[e._v("Master entries")]),e._v("缓存起来。因为 AppCache 出现的时候还是以静态网站为主，所以并不能缓存请求的 Ajax 数据。我们需要自己再手动实现缓存所有请求在"),t("code",[e._v("localStorage")]),e._v("，但是"),t("code",[e._v("localStorage")]),e._v("同样也有最大 5MB 的限制。所以也需要考虑相应的解决方案。不过，我最终采取的方式是通过嵌入"),t("code",[e._v("iframe")]),e._v("来实现触发 AppCache，这样做的好处是因为 SPA 应用是自己来控制路由的，所以导致每个路径都会保存一份"),t("code",[e._v("Master entries")]),e._v("。但是通过 iframe 的话，我们的"),t("code",[e._v("Master entries")]),e._v("永远只有一份。并且当前页面的所有资源也被顺利缓存，因为 SPA 无论访问哪个路径返回的都是相同的"),t("code",[e._v("index.html")]),e._v("。由 JS 来控制路由并加载相应的组件。")]),e._v(" "),t("p",[e._v("这里要补充的一点是，针对 https 的 Application Cache 是无法完成跨域请求的，所以请慎重。")]),e._v(" "),t("h2",{attrs:{id:"workbox"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#workbox"}},[e._v("#")]),e._v(" WorkBox")]),e._v(" "),t("p",[e._v("Service Worker 是现在主流的缓存技术，会帮你缓存所有的静态文件和数据请求。但是对于 SPA 项目，我们不可能自己手动书写缓存清单。所以还是借助现有的开源解决方案，这里最出名的解决方案是谷歌的 Workbox。通过使用 Webpack 插件和简单的配置，我们便可以做到缓存所有的静态资源和数据。Service Worker 有很多种缓存策略可以选择，例如 Cache First 和 NetWork First。但是 AppCache 每次都会优先使用缓存，然后再去更新最新的文件。所以我们不得不在发生更新的时候去重新加载页面。")]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("最终的解决方案是优先使用 Service Worker，当不支持 Service Worker 的时候再回退到 AppCache。但是想要从 AppCache 升级到 Service Worker 的时候，必须清除所有 AppCache 的所有数据。浏览器并没有提供相应的接口，我们目前采用的方式是手动删除 AppCache 储存的数据库来完成这一需求。")]),e._v(" "),t("p",[e._v("参考：")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache",target:"_blank",rel:"noopener noreferrer"}},[e._v("Using the application cache"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/SafariJSDatabaseGuide/OfflineApplicationCache/OfflineApplicationCache.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTML5 Offline Application Cache"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/lettertwo/appcache-webpack-plugin",target:"_blank",rel:"noopener noreferrer"}},[e._v("Application Cache plugin for Webpack"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin",target:"_blank",rel:"noopener noreferrer"}},[e._v("Workbox webpack Plugins"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://appcachefacts.info/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Appcache Facts"),t("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=n.exports}}]);