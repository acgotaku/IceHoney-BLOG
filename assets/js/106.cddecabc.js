(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{396:function(s,a,t){"use strict";t.r(a);var e=t(10),n=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("p",[s._v("容器化部署已经成为现在的主流，打包 docker 镜像已经是现代前端开发的必修课了。最近正好在做新项目的时候处理过相关事情，所以记录一下。")]),s._v(" "),t("h2",{attrs:{id:"docker-部署的需求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-部署的需求"}},[s._v("#")]),s._v(" docker 部署的需求")]),s._v(" "),t("p",[s._v("首先我们需要使用 docker 完成网站源代码的编译，并且还要自己使用 "),t("a",{attrs:{href:"https://expressjs.com/",target:"_blank",rel:"noopener noreferrer"}},[s._v("expressjs"),t("OutboundLink")],1),s._v(" 搭建服务器。让网站可以运行，docker 跑起来之后只用负责端口转发即可。")]),s._v(" "),t("p",[s._v("大家都知道前端网站编译需要安装很多依赖，但这些依赖在网站运行的时候并不需要。那如何才能做到，编译之后丢弃这些不用的依赖呢？ 我一开始尝试主动删除，但发现并没有减少 docker 的大小。")]),s._v(" "),t("p",[s._v("答案是"),t("a",{attrs:{href:"https://docs.docker.com/develop/develop-images/multistage-build/",target:"_blank",rel:"noopener noreferrer"}},[s._v("Use multi-stage builds"),t("OutboundLink")],1)]),s._v(" "),t("h2",{attrs:{id:"编译网站"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译网站"}},[s._v("#")]),s._v(" 编译网站")]),s._v(" "),t("p",[s._v("首先我们需要安装依赖并编译网站，dockerfile 内容如下：")]),s._v(" "),t("div",{staticClass:"language-dockerfile line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("14.17.5"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("buster"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("slim as build\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ARG")]),s._v(" GITHUB_PACKAGES_TOKEN\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" apt"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("get update && apt"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("get install "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("y "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("no"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("install"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("recommends autoconf automake g++ libpng"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("dev make\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# use changes to package.json to force Docker not to use the cache")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# when we change our application's nodejs dependencies:")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COPY")]),s._v(" package.json yarn.lock /tmp/\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" echo $GITHUB_PACKAGES_TOKEN\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" cd /tmp && yarn install "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("forzen"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("lockfile "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("production=false\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" mkdir "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("p /app && mv /tmp/node_modules /app\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# From here we load our application's code in, therefore the previous docker")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v('# "layer" thats been cached will be used if possible')]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WORKDIR")]),s._v(" /app\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COPY")]),s._v(" . /app\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ENV")]),s._v(" NODE_ENV production\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" yarn build && yarn express"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("build\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br")])]),t("p",[s._v("上面的命令编译了网站和 express 服务端代码，这里选择的 node 官方镜像并不是精简版，因为编译的时候需要很多依赖，精简版的话反而安装系统依赖更花时间。")]),s._v(" "),t("h2",{attrs:{id:"安装依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装依赖"}},[s._v("#")]),s._v(" 安装依赖")]),s._v(" "),t("p",[s._v("网站运行并不需要 node_modules 但是 express 服务器是需要的，所以我们需要安装后端的依赖。")]),s._v(" "),t("div",{staticClass:"language-dockerfile line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("14.17.5"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("alpine3.14 as deps\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# use changes to package.json to force Docker not to use the cache")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# when we change our application's nodejs dependencies:")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COPY")]),s._v(" server/package.json server/yarn.lock /tmp/\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("RUN")]),s._v(" cd /tmp && yarn install "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("forzen"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("lockfile "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("production=false\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("p",[s._v("服务端的 "),t("code",[s._v("package.json")]),s._v(" 文件我放在了 server 文件夹下，服务端依赖的东西很少，所以不太占用空间。")]),s._v(" "),t("h2",{attrs:{id:"打包实际生成的文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包实际生成的文件"}},[s._v("#")]),s._v(" 打包实际生成的文件")]),s._v(" "),t("div",{staticClass:"language-dockerfile line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" node"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("14.17.5"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("alpine3.14\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WORKDIR")]),s._v(" /app\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COPY")]),s._v(" . /app\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COPY")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("from=deps /tmp/node_modules ./node_modules/\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COPY")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("from=build /app/dist ./dist/\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COPY")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("from=build /app/server ./server/\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("p",[s._v("接下来的步骤很简单了， 选择占用空间最小的 "),t("code",[s._v("Alpine Linux")]),s._v(" 然后把编译好的文件复制进来就可以了。前两个步骤的所有东西都会被丢弃掉。所以实际生成的 docker 镜像会非常小。")]),s._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),t("p",[s._v("采用多阶段编译，可以有效的减少编译的依赖对空间的占用，做到最小化 docker 镜像。")]),s._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[s._v("#")]),s._v(" 参考")]),s._v(" "),t("p",[t("a",{attrs:{href:"https://learnk8s.io/blog/smaller-docker-images",target:"_blank",rel:"noopener noreferrer"}},[s._v("3 simple tricks for smaller Docker images"),t("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=n.exports}}]);