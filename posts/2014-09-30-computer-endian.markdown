---
layout: post
title: "计算机中的字节序问题"
date: 2014-09-30 12:30
comments: true
tags: endian
---

计算机字节序这个问题,最近被老师反复提到.我也在本科阶段折腾交叉编译的时候遇到过.
并且这个问题貌似也是面试的时候一个常见问题,所以还是写下来比较好.

字节序顾名思义就是计算机中字节的存储顺序.目前最常见的就是大端字节序和小端字节序.
貌似百科里面又有一个中端字节序...(不过确实很少见)

#大端字节序

按照最高位字节(包含最高位,即MSB,的字节)至最低位字节(包含最低位,即LSB,的字节)的顺序,存放在连续的地址中.

采用这种机制的处理器有IBM3700系列,和绝大多数的RISC处理(我的路由器就是)

#小端字节序

按照最低位字节(包含LSB的字节)至最高位字节(包含MSB的字节)的顺序,存放在连续的地址中.

采用这种机智的处理器最常见的就是Intel系列处理器

#判断字节序
当然字节序不能完全靠处理器来判断,因为有些处理器可能既支持大端字节序又支持小端字节序
最好用的方式还是用个程序跑一跑,实践是检验整理的唯一标准.

		#include <stdio.h>
		int main()
		{
		    unsigned int x = 0x12345678;
		    char *p = (char *)&x;
		    int i;
		    for (i = 0; i < sizeof(x); i++){
		        printf("%.2x ", *p++);
		    }
		    printf("\n");
		    return 0;
		}

上面的一段C程序就可以检验字节序,   
如果输出是：12 34 56 78,那么CPU是大端字节序.  
如果输出时：78 56 34 12,那么CPU是小端字节序.  
输出证明,大端字节序更适合人类阅读.

#涉及字节序的问题

谈到字节序问题,是因为网络编程的时候如果双方的字节序不一样
肯定会出问题的.本人在交叉编译学校的校园网程序的时候就是
遇到了这个问题,因为字节序的不同,导致发送的数据包是相反的.
后来在老师的点拨下才得以解决.